{"version":3,"file":"coroutines.esm.js","sources":["../coroutines.ts"],"sourcesContent":["\n/**\n * A coroutine container.\n * \n * Coroutines are added to a schedule with [[add]] and all scheduled\n * coroutines are advanced with [[tick]].\n */\nexport class Schedule {\n    private coroutines : Generator<any>[] = []\n    /**\n     * For debugging\n     */\n    public readonly name : string;\n    \n    constructor(name = generateNewName()) {\n        this.name = name;\n    }\n\n    /**\n     * Schedules a coroutine for evaluation.\n     * \n     * Future calls to [[tick]] will run `coro` up to its next `yield` until it is completed.\n     * \n     * As a convenience if `coro` is a generator function and not a generator, it will be evaluated to produce a generator.\n     * \n     * ```js\n     * function* coroutineFunction() { ... }\n     * let schedule = new Schedule()\n     * schedule.add(coroutineFunction()) // this works\n     * schedule.add(coroutineFunction)   // so does this\n     * ```\n     * \n     * @param coro coroutine to add\n     */\n    public add(coro:Generator<any>|(()=>Generator<any>)) {\n        let c = \"next\" in coro ? coro : coro();\n        this.coroutines.push(c)\n        return c\n    }\n\n    /**\n     * Stops a single coroutine\n     * \n     * @param coro coroutine to remove\n     */\n    public remove(coro: Generator<any>) {\n        this.coroutines.splice(this.coroutines.indexOf(coro), 1)\n    }\n\n    /**\n     * Discards all scheduled coroutines\n     */\n    public removeAll() {\n        this.coroutines = []\n    }\n\n    /**\n     * Advances all scheduled coroutines once.\n     * \n     * Each coroutine added with [[add]] will run up to its next `yield` statement. Finished coroutines are removed\n     * from the collection.\n     */\n    public tick() {\n        let toRemove = []\n        for(const coro of this.coroutines) {\n            let result = coro.next()\n            if(result.done) {\n                toRemove.push(coro)\n            }\n      }\n      for (const x of toRemove) {\n        this.coroutines.splice(this.coroutines.indexOf(x), 1)\n      }\n    }\n}\n\nlet generateNewName = () => Math.random().toString(36).replace(\"0.\", \"Schedule.\")\n\nif(typeof window === \"undefined\") {\n    global[\"performance\"] = require(\"perf_hooks\").performance;\n}\n\nlet _clock = () => performance.now() / 1000\n\n/**\n * Sets a new clock function.\n * \n * The clock function returns the elapsed application time in seconds. It is called by some coroutines to measure the\n * passage of time. defaults to `performance.now() / 1000`\n *\n * @param f New clock function\n */\nexport function setClock(f: () => number) {\n    _clock = f\n}\n\n/**\n * Wait for a number of seconds.\n * \n * @category Coroutine\n * \n * @param seconds How many seconds to wait\n * @param clock A function that returns the elapsed application time in seconds, defaults to the function assigned by [[setClock]]\n * @see [[setClock]]\n */\nexport function* wait(seconds: number, clock = _clock) {\n    let startTime = clock()\n    while (clock() - startTime < seconds) {\n        yield;\n    }\n}\n\n/**\n * Wait for a number of frames.\n * \n * @category Coroutine\n * \n * @param n How many frames to wait\n */\nexport function* waitFrames(n: number) {\n    while (n-- > 0) {\n        yield;\n    }\n}\n\n/**\n * Wait until a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns truthy this coroutine completes.\n */\nexport function* waitUntil(f: () => boolean) {\n    while(!f()) {\n        yield;\n    }\n}\n\n/**\n * Wait while a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns falsey this coroutine completes.\n */\nexport function* waitWhile(f: () => boolean) {\n    while(f()) {\n        yield;\n    }\n}\n\n// /**\n//  * Animate a parameter.\n//  * \n//  * @category Coroutine\n//  * \n//  * \n//  * @param obj The object to mutate\n//  * @param prop The property on `obj` to mutate\n//  * @param to The final value of `obj.prop`\n//  * @param map A function to shape the animation curve. Given a value between 0 and 1 returns a value between 0 and 1. Defaults to the identity function (no shaping).\n//  * @param map.x A value between 0 and 1\n//  * @param clock The clock function used to measure time. Defaults to the function set by [[setClock]]\n//  * @param interpolate Interpolating function. Given values `a` and `b` returns their interpolated value at `t`, a number between 0 and 1. Defaults to linear interpolation.\n//  * @param interpolate.a The starting value\n//  * @param interpolate.b The final value\n//  * @param interpolate.t The interpolation value, a number between 0 and 1\n//  * @todo needs way to specify animation speed or time\n//  * @see [[setClock]]\n//  */\n// export function* animate(obj: any, prop: string, to:any, { clock = _clock, map = (x:number) => x, interpolate = (a:any, b:any, t:number) => b * t + a * (1 - t) } ) {\n//     let from = obj[prop];\n//     let t = 0\n//     let lastTime = clock()\n//     while(t < 1) {\n//         let nowTime = clock()\n//         let delta = nowTime - lastTime\n//         lastTime = nowTime\n//         obj[prop] = interpolate(from, to, map(t))\n//         t += delta\n//         yield;\n//     }\n// }\n\nlet advance = (c:Generator<any>) => c.next()\n\nlet initialize = (c:(Generator<any>|(()=>Generator<any>))) => typeof c === \"function\" ? c() : c\n\n/**\n * Returns a coroutine that waits for every coroutine of `coros` to complete.\n * \n * @category Combinator\n * @param coros The coroutines to wait for\n */\nexport function* waitAll(coros:Generator<any>[]) {\n    let results = coros.map(advance)\n    while(results.filter(r => r.done).length !== coros.length) {\n      yield;\n      for (var i = 0; i < coros.length; i++) {\n        let coro = coros[i]\n        let res = results[i]\n        if(!res.done) {\n          results[i] = advance(coro)\n        }\n      }\n    }\n  }\n  \n  /**\n   * Returns a coroutine that waits for the first coroutine of `coros` to complete.\n   * \n   * @category Combinator\n   * @param coros The coroutines to wait for\n   */\n  export function* waitFirst(coros:Generator<any>[]) {\n    coros = coros.map(initialize)\n    while(true) {\n        for (const c of coros) {\n            let res = c.next()\n            if(res.done)\n                return res.value;\n        }\n        yield\n    }\n  }\n\n//   /**\n//    * Returns a coroutine that completes each coroutine in `coros` in turn\n//    * \n//    * @category Combinator\n//    * @param coros The coroutines to complete\n//    */\n// export function* sequence(coros:(Generator<any>|(()=>Generator<any>))[]) {\n//     for (const coro of coros) {\n//         yield* initialize(coro)\n//     }\n//   }"],"names":[],"mappings":"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"}
{"version":3,"file":"coroutines.esm.js","sources":["../coroutines.ts"],"sourcesContent":["\n/**\n * A container for running coroutines.\n * \n * @remarks this might be renamed \"Timeline\" in the future  \n * \n */\nexport class Coroutines {\n    private coroutines : Iterator<any>[] = []\n    \n    /**\n     * Set to `false` to exit a [[startTicking]] loop\n     */\n    public active = true\n\n    /**\n     * For debugging\n     */\n    public readonly name : string;\n    \n    constructor(name = generateNewName()) {\n        this.name = name;\n    }\n\n    /**\n     * Schedules a coroutine for evaluation.\n     * \n     * Future calls to [[tick]] will run `coro` up to its next `yield` until it is completed.\n     * \n     * As a convenience if `coro` is a generator function and not a generator, it will be evaluated to produce a generator.\n     * \n     * ```js\n     * function* coroutineFunction() { ... }\n     * let coro = new Coroutines()\n     * coro.start(coroutineFunction()) // this works\n     * coro.start(coroutineFunction)   // so does this\n     * ```\n     * \n     * @param coro coroutine to start\n     */\n    public start(coro:Iterator<any>|(()=>Iterator<any>)) {\n        let c = \"next\" in coro ? coro : coro();\n        this.coroutines.push(c)\n        return c\n    }\n\n    /**\n     * Stops a single coroutine\n     * \n     * @param coro coroutine to stop\n     */\n    public stop(coro: Iterator<any>) {\n        this.coroutines.splice(this.coroutines.indexOf(coro), 1)\n    }\n\n    /**\n     * Discards all scheduled coroutines\n     */\n    public stopAll() {\n        this.coroutines = []\n    }\n\n    /**\n     * Runs all scheduled coroutines once.\n     * \n     * Each coroutine added with [[start]] will run up to its next `yield` statement. Finished coroutines are removed\n     * from the collection.\n     */\n    public tick() {\n        let toRemove = []\n        for(const coro of this.coroutines) {\n            let result = coro.next()\n            if(result.done) {\n                toRemove.push(coro)\n            }\n      }\n      for (const x of toRemove) {\n        this.coroutines.splice(this.coroutines.indexOf(x), 1)\n      }\n    }\n\n    /**\n     * Start running coroutines every frame.\n     * \n     * Calls [[tick]] every \"frame\" as long as [[active]] is true.\n     * \n     * The meaning of \"a frame\" depends on the scheduling function. In a browser, requestAnimationFrame is the default \n     * and a frame happens every 1/60 seconds or 16.6ms or 60Hz. In node, process.nextTick is the default and a frame\n     * happens every iteration of the event loop, which is typically much faster than 1/60 seconds. Coroutines that\n     * measure physical time are not affected by this difference.\n     * \n     * @param scheduleFunction defaults to\n     * [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)\n     * in a browser and [setImmediate](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate) otherwise.\n     */\n    public startTicking(scheduleFunction:Function=_scheduleFunction) {\n        let runCoroutines = () => {\n            this.tick()\n            if(this.active)\n                scheduleFunction(runCoroutines)\n        }\n        runCoroutines()\n    }\n}\n\nlet generateNewName = () => Math.random().toString(36).replace(\"0.\", \"Coroutines.\")\n\nlet _scheduleFunction = typeof window === \"undefined\" ? setImmediate : requestAnimationFrame\n\nif(typeof window === \"undefined\") {\n    global[\"performance\"] = require(\"perf_hooks\").performance;\n}\n\nlet _clock = () => performance.now() / 1000\n\n/**\n * Sets a new clock function.\n * \n * The clock function returns the elapsed application time in seconds. It is called by some coroutines to measure the\n * passage of time. defaults to `performance.now() / 1000`\n *\n * @param f New clock function\n */\nexport function setClock(f: () => number) {\n    _clock = f\n}\n\n/**\n * Wait for a number of seconds.\n * \n * @category Coroutine\n * \n * @param seconds How many seconds to wait\n * @param clock A function that returns the elapsed application time in seconds, defaults to the function assigned by [[setClock]]\n * @see [[setClock]]\n */\nexport function* wait(seconds: number, clock = _clock) {\n    let startTime = clock()\n    while (clock() - startTime < seconds) {\n        yield;\n    }\n}\n\n/**\n * Wait for a number of frames.\n * \n * @category Coroutine\n * \n * @param n How many frames to wait\n */\nexport function* waitFrames(n: number) {\n    while (n-- > 0) {\n        yield;\n    }\n}\n\n/**\n * Wait until a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns truthy this coroutine completes.\n */\nexport function* waitUntil(f: () => boolean) {\n    while(!f()) {\n        yield;\n    }\n}\n\n/**\n * Wait while a function `f` returns true.\n * \n * @category Coroutine\n * \n * @param f A function to execute every frame. When `f` returns falsey this coroutine completes.\n */\nexport function* waitWhile(f: () => boolean) {\n    while(f()) {\n        yield;\n    }\n}\n\n/**\n * Animate a parameter.\n * \n * @category Coroutine\n * \n * \n * @param obj The object to mutate\n * @param prop The property on `obj` to mutate\n * @param to The final value of `obj.prop`\n * @param map A function to shape the animation curve. Given a value between 0 and 1 returns a value between 0 and 1. Defaults to the identity function (no shaping).\n * @param map.x A value between 0 and 1\n * @param clock The clock function used to measure time. Defaults to the function set by [[setClock]]\n * @param interpolate Interpolating function. Given values `a` and `b` returns their interpolated value at `t`, a number between 0 and 1. Defaults to linear interpolation.\n * @param interpolate.a The starting value\n * @param interpolate.b The final value\n * @param interpolate.t The interpolation value, a number between 0 and 1\n * @todo needs way to specify animation speed or time\n * @see [[setClock]]\n */\nexport function* animate(obj: any, prop: string, to:any, { clock = _clock, map = (x:number) => x, interpolate = (a:any, b:any, t:number) => b * t + a * (1 - t) } ) {\n    let from = obj[prop];\n    let t = 0\n    let lastTime = clock()\n    while(t < 1) {\n        let nowTime = clock()\n        let delta = nowTime - lastTime\n        lastTime = nowTime\n        obj[prop] = interpolate(from, to, map(t))\n        t += delta\n        yield;\n    }\n}"],"names":[],"mappings":"AACA;;;;;;AAMA,MAAa,UAAU;IAanB,YAAY,IAAI,GAAG,eAAe,EAAE;QAZ5B,eAAU,GAAqB,EAAE,CAAA;;;;QAKlC,WAAM,GAAG,IAAI,CAAA;QAQhB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACpB;;;;;;;;;;;;;;;;;IAkBM,KAAK,CAAC,IAAsC;QAC/C,IAAI,CAAC,GAAG,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,EAAE,CAAC;QACvC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QACvB,OAAO,CAAC,CAAA;KACX;;;;;;IAOM,IAAI,CAAC,IAAmB;QAC3B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAA;KAC3D;;;;IAKM,OAAO;QACV,IAAI,CAAC,UAAU,GAAG,EAAE,CAAA;KACvB;;;;;;;IAQM,IAAI;QACP,IAAI,QAAQ,GAAG,EAAE,CAAA;QACjB,KAAI,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;YAC/B,IAAI,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;YACxB,IAAG,MAAM,CAAC,IAAI,EAAE;gBACZ,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;aACtB;SACN;QACD,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;YACxB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;SACtD;KACF;;;;;;;;;;;;;;;IAgBM,YAAY,CAAC,mBAA0B,iBAAiB;QAC3D,IAAI,aAAa,GAAG;YAChB,IAAI,CAAC,IAAI,EAAE,CAAA;YACX,IAAG,IAAI,CAAC,MAAM;gBACV,gBAAgB,CAAC,aAAa,CAAC,CAAA;SACtC,CAAA;QACD,aAAa,EAAE,CAAA;KAClB;CACJ;AAED,IAAI,eAAe,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,aAAa,CAAC,CAAA;AAEnF,IAAI,iBAAiB,GAAG,OAAO,MAAM,KAAK,WAAW,GAAG,YAAY,GAAG,qBAAqB,CAAA;AAE5F,IAAG,OAAO,MAAM,KAAK,WAAW,EAAE;IAC9B,MAAM,CAAC,aAAa,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,WAAW,CAAC;CAC7D;AAED,IAAI,MAAM,GAAG,MAAM,WAAW,CAAC,GAAG,EAAE,GAAG,IAAI,CAAA;;;;;;;;;AAU3C,SAAgB,QAAQ,CAAC,CAAe;IACpC,MAAM,GAAG,CAAC,CAAA;CACb;;;;;;;;;;AAWD,UAAiB,IAAI,CAAC,OAAe,EAAE,KAAK,GAAG,MAAM;IACjD,IAAI,SAAS,GAAG,KAAK,EAAE,CAAA;IACvB,OAAO,KAAK,EAAE,GAAG,SAAS,GAAG,OAAO,EAAE;QAClC,KAAK,CAAC;KACT;CACJ;;;;;;;;AASD,UAAiB,UAAU,CAAC,CAAS;IACjC,OAAO,CAAC,EAAE,GAAG,CAAC,EAAE;QACZ,KAAK,CAAC;KACT;CACJ;;;;;;;;AASD,UAAiB,SAAS,CAAC,CAAgB;IACvC,OAAM,CAAC,CAAC,EAAE,EAAE;QACR,KAAK,CAAC;KACT;CACJ;;;;;;;;AASD,UAAiB,SAAS,CAAC,CAAgB;IACvC,OAAM,CAAC,EAAE,EAAE;QACP,KAAK,CAAC;KACT;CACJ;;;;;;;;;;;;;;;;;;;;AAqBD,UAAiB,OAAO,CAAC,GAAQ,EAAE,IAAY,EAAE,EAAM,EAAE,EAAE,KAAK,GAAG,MAAM,EAAE,GAAG,GAAG,CAAC,CAAQ,KAAK,CAAC,EAAE,WAAW,GAAG,CAAC,CAAK,EAAE,CAAK,EAAE,CAAQ,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7J,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;IACrB,IAAI,CAAC,GAAG,CAAC,CAAA;IACT,IAAI,QAAQ,GAAG,KAAK,EAAE,CAAA;IACtB,OAAM,CAAC,GAAG,CAAC,EAAE;QACT,IAAI,OAAO,GAAG,KAAK,EAAE,CAAA;QACrB,IAAI,KAAK,GAAG,OAAO,GAAG,QAAQ,CAAA;QAC9B,QAAQ,GAAG,OAAO,CAAA;QAClB,GAAG,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;QACzC,CAAC,IAAI,KAAK,CAAA;QACV,KAAK,CAAC;KACT;CACJ;;;;"}